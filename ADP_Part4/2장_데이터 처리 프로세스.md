# 2장. 데이터 처리 기술
## 학습목표
    - 분산 파일 시스템, 공유 스토리지 등의 저장 기술의 종류와 기능을 이해한다
    - 분산 병렬 처리 기술에 대해 이해한다
    - 서버 가상화를 중심으로 한 클라우드 인프라 기술들을 이해한다
<hr>

## 1절. 분산 데이터 저장 기술
### 1. 분산 파일 시스템
#### 가. 분산 파일 시스템의 개요
    - 분산 파일시스템, 클러스터, 데이터베이스, NoSQL로 구분
    - 파일의 메타데이터를 관리하는 전용 서버를 가지고 있는 비대칭형 클러스터 파일 시스템 개발
    - 메타데이터에 접근하는 경로와 데이터에 접근하는 경로가 분리된 구조
#### 나. 구글 파일 시스템(GFS, Google File System)
##### 1) 개념 및 특징
    - 파일을 고정된 크기의 청크로 나누고, 각 청크에 대한 여러 개의 복제본과 청크를 청크서버에 분산 저장한다
    - 트리 구조가 아닌 해시 테이블 구조 등을 사용해서 메모리상 효율적
    - 청크는 마스터에 의해 생성/삭제 가능, 유일한 식별자에 의해 구별
##### 2) GFS 설계의 가정
    - 서버의 고장이 빈번할 수 있다.
    - 대부분의 파일은 대용량
    - 작업의 부하는 주로 연속적으로 많은 데이터를 읽는 연산 또는 임의의 영역에서 적은 데이터를 읽는 연산에서 발생
    - 쓰기연산은 순차적, 파일에 대한 갱신은 드물게 이루어진다
    - 동기화 오버헤드를 최소화할 수 있는 방법 요구
    - 낮은 응답 지연시간보다 높은 처리율이 더 중요하다
##### 3) GFS의 구성요소
|||
|:--:|:--|
|클라이언트|- 파일에 대한 읽기/쓰기 동작을 요청하는 애플리케이션으로 POSIX(Portable Operating System Interface) 인터페이스를 지원하지 않으며, 파일 시스템 인터페이스와 유사한 자체 인터페이스를 지원<br/>- 여러 클라이언트에서 원자적인 추가(atomic append)연산을 지원하기 위한 인터페이스를 지원|
|마스터|- 단일 마스터 구조로 파일 시스템의 이름 공간(name space), 파일과 chunk의 매핑 정보, 각 chunk가 저장된 청크서버들의 위치 정보 등에 해당하는 모든 메타 데이터를 메모리상에서 관리<br/>- 주기적으로 수집되는 청크서버의 하트비트 메시지를 이용하여 chunk들의 상태에 따라 chunk를 재복제하거나 재분산하는 것과 같은 회복동작을 수행<br/>- 하나의 chunk 서버를 primary로 지정하여 복제본의 갱신 연산을 일관되게 처리할 수 있도록 보장<br/>- 마스터에 대한 장애 처리와 회복을 위해 파일시스템 이름 공간과 파일의 chunk 매핑 변경 연산을 로깅하고, 마스터의 상태를 여러 섀도 마스터에 복제|
|청크서버|- 로컬 디스크에 chunk를 저장, 관리하면서 클라이언트로부터의 chunk 입출력 요청을 처리<br/>- 하트비트 메시지를 통해 청크서버의 상태에 대한 정보를 주기적으로 마스터에게 전달|
<hr>

##### 4) GFS에서 파일을 읽어오는 과정
![GFS](./GFS.png)
    - 클라이언트는 파일에 접근하기 위해 마스터로부터 해당 파일의 chunk가 저장된 chunk서버의 위치와 핸들을 먼저 받아온 뒤, 직접 청크서버에게 파일 데이터를 요청한다
#### 다. 하둡 분산 파일 시스템(HDFS, Hadoop Distributed File System)
##### 1) 개념 및 특징
    - HDFS는 GFS의 마스터와 유사한 하나의 네임노드(NameNode), GFS의 청크서버와 유사한 다수의 데이터노드(Datanode)로 구성
    - HDFS에서 파일 데이터는 블록단위로 나뉘어 여러 데이터노드에 분산,복제,저장
    - HDFS에서 기본적으로 파일은 한 번 쓰이면 변경되지 않는다고 가정(2.0 알파버전부터는 저장된 파일에 append가 가능)
    - HDFS는 순차적 스트리밍 방식으로 파일을 저장하거나 저장된 파일을 조회, 배치 작업에 적합하도록 설계
    - 낮은 데이터 접근 지연 시간보다는 높은 데이터 처리량에 중점
    - 클라이언트, 네임노드, 데이터노드 간의 통신을 위하여 TCP/IP 네트워크상에서 RPC를 사용
##### 2) HDFS의 구성요소
|||
|:--:|:--|
|네임노드|- 파일 시스템의 이름 공간 등 HDFS 상의 모든 메타데이터를 관리하며, 마스터/슬레이브 구조에서 마스터의 역할을 함<br/>- 파일이 어떤 형태의 블록 단위로 나누어져 있고, 어떤 노드에 특정 블록이 있는지 등 시스템 전반의 상태를 모니터링<br/> - 데이터를 저장하거나 애플리케이션을 실행하는 작업은 수행하지 않음<br/>- 클라이언트로부터의 파일 접근 요청을 처리<br/>- 데이터노드들로부터 하트비트를 받아 데이터노드들의 상태를 체크하는데, 하트비트 메시지에 포함된 블록정보를 가지고 블록의 상태를 체크할 수 있음|
|데이터노드|- HDFS의 슬레이브 노드로, 클라이언트로부터의 데이터 입출력 요청을 처리<br/>- 데이터의 유실을 방지하기 위해 블록을 3중 복제하여 저장<br/>- 블록을 저장할 때, 해당 블록에 대한 파일의 체크섬 정보를 별도로 저장<br/> - 주기적으로 데이터노드의 상태를 나타내는 하트비트와 자신이 관리하는 블록의 목록인 blockreport를 네임노드에게 전송|
|보조네임노드|- HDFS 상태 모니터링을 보조<br/>- 주기적으로 네임 노드의 파일 시스템 이미지를 스냅샷해 생성|
##### 3) HDFS의 파일 저장 과정
![hdfs-8-638](./hdfs-8-638.jpg)
    - 클라이언트는 저장할 파일을 여러 단위블록으로 분리
    - 블록을 저장하기 위한 데이터노드 주소를 받은뒤, 첫 번째 데이터노드에게 데이터를 전송
    - 첫 번째 데이터 노드는 전송받은 데이터를 저장한 후, 두 번째 데이터노드로 전달
    - 두 번째 데이터 노드도 전달받은 데이터를 저장한 후, 세 번째 데이터노드로 전달
    - 세 번째 데이터 노드까지의 데이터 저장이 완료되면, 각 데이터노드들은 순차적으로 클라이언트에게 저장이 완료되었다는 신호를 보냄
    - 이러한 과정을 모든 블록의 저장이 완료될 때까지 반복한다
    - 모든 블록의 저장이 완료되면 네임노드는 블록들이 저장된 데이터노드의 주소, 즉 파일에 대한 메타 데이터를 저장
##### 4) HDFS의 파일 읽기 과정
![hdfs-7-638](./hdfs-7-638.jpg)
    - 클라이언트는 읽고자 하는 파일에 대한 정보를 네임노드에게 요청
    - 네임노드는 파일에 대한 모든 블록의 목록과 블록이 저장된 데이터 노드의 위치를 클라이언트에게 반환
    - 클라이언트는 전달받은 블록의 위치를 이용해 데이터노드로부터 직접 데이터를 읽어 들인다

#### 라. 러스터(Lustre)
##### 1) 개념 및 특징
    - 객체 기반의 클러스터 파일 시스템
    - 클라이언트 파일 시스템, 메타데이터 서버, 객체 저장서버로 구성
    - 계층화된 모듈 구조 TCP/IP, 인피니밴드, 미리넷과 같은 네트워크 지원
##### 2) 구성요소
|||
|:--:|:--|
|클라이언트 파일 시스템|- 리눅스 VFS(Virtual File System)에서 설치할 수 있는 파일 시스템<br/>- 메타데이터 서버와 객체 저장 서버들과 통신하면서 클라이언트 응용에 파일 시스템 인터페이스 제공|
|메타데이터 서버|- 파일 시스템의 이름 공간과 파일에 대한 메타데이터를 관리|
|객체 저장 서버|- 파일데이터를 저장하고, 클라이언트로부터의 객체 입출력 요청을 처리<br/>- 데이터는 세그먼트라는 작은 데이터 단위로 분할해서 복수의 디스크 장치에 분산시키는 기술인 스트라이핑 방식으로 분산 저장|
##### 3) 구동방식
    - 러스터는 유닉스 시맨틱을 제공하면서 파일 메타데이터에 대해서는 라이트백 캐시를 지원
    - 클라이언트에서 메타데이터 변경에 대한 갱신 레코드를 생성하고 나중에 메타데이터 서버에 전달
    - 메타데이터 서버는 전달된 갱신 레코드를 재수행하여 변경된 메타데이터를 반영
    - 메타데이터 서버에서는 메타데이터를 동시에 접근하는 부하에 따라 클라이언트 캐시에서 라이트백 캐시를 지원하거나 메타데이터 서버에서 메타데이터를 처리하는 방식을 적용
    - 러스터는 메타데이터 서버에서 처리하도록 하는 방식을 사용해 메타데이터에 대한 동시 접근이 적으면 클라이언트 캐시를 이용한 라이트백 캐시를 사용하고, 메타데이터에 대한 동시접근이 많으면 클라이언트 캐시를 사용함으로써 발생할 수 있는 오버헤드를 줄인다.
    - 러스터는 파일의 메타데이터와 파일 데이터에 대한 동시성 제어를 위해 별도의 잠금을 사용한다.
    - 메타데이터에 접근하기 위해서는 메타데이터 서버의 잠금 서버로부터 잠금을 획득해야 한다.
    - 파일 데이터에 접근하기 위해서는 해당 데이터가 저장된 객체 저장 서버의 잠금 서버로부터 잠금을 획득해야 한다
    - 러스터는 클라이언트와 메타데이터 서버 간의 네트워크 트래픽을 최소화하기 위하여 메타데이터에 대한 잠금 요청 시에 메타데이터 접근 의도를 같이 전달하는 인텐트 기반 잠금 프로토콜을 사용한다
    - 메타데이터 서버는 메타데이터 접근 의도에 따라 해당 동작을 수행하고, 잠금을 승인하는 처리를 함꼐 수행함으로써 클라이언트와 메타데이터 서버간의 네트워크 트래픽을 줄일 수 있다. 
#### 마. 파일 시스템 비교
|구분|GFS|하둡 DFS|러스터|
|:--:|:--:|:--:|:--:|
|Open Source|O|O|O|
|Chunk Based|O|O|X|
|Support Replication|O|O|X|
|Multiple metadata server supported|X|X|X|
|Locks used to maintain atomicity|O|O|O|
|Uses a DB for storing metadata|X|X|X|
|Adding nodes without shutting down the system|O|O|O|
|POSIX support|X|X|O|
|Supports file modification|X|X|O|
<hr>

### 2. 데이터베이스 클러스터
#### 가. 개념
    - 하나의 데이터베이스를 여러 개의 서버상에 구축하는 것을 의미
    - 데이터베이스 파티셔닝은 데이터베이스를 여러 부분으로 분할하는 것
    - 분할된 각 요소는 파티션
    - 각 파티션은 여러 노드로 분할 배치되어 여러 사용자가 각 노드에서 트랜잭션을 수행
    - 데이터를 통합할 때, 성능과 가용성의 향상을 위해 데이터베이스 차원의 파티셔닝 또는 클러스터링을 이용
#### 나. 데이터베이스 파티셔닝 구현의 효과
|||
|:--:|:--|
|병렬처리|파티션 사이의 병렬 처리를 통한 빠른 데이터 검색 및 처리 성능을 얻을 수 있다|
|고가용성|특정 파티션에서 장애가 발생하더라도 서비스가 중단되지 않는다|
|성능향상|성능의 선형적인 증가 효과를 볼 수 있다|
#### 다. 데이터베이스 클러스터의 구분
##### 1) 무공유 디스크
    - 무공유 클러스터에서 각 데이터베이스 인스턴스는 자신이 관리하는 데이터 파일을 자신의 로컬 디스크에 저장하며, 이 파일들은 노드 간에 공유하지 않는다
    - 각 인스턴스나 노드는 완전히 분리된 데이터의 서브 집합에 대한 소유권을 가지고 있으며, 각 데이터는 소유권을 갖고 있는 인스턴스가 처리
    - 한 노드가 데이터 처리 요청을 받으면, 해당 노드는 처리할 데이터를 갖고 있는 노드에 신호를 보내 데이터 처리를 요청
    - Oracle RAC(Real Application Cluster)를 제외한 대부분의 데이터베이스 클러스터가 무공유 방식을 채택
|||
|:--:|:--|
|장점|노드 확장에 제한이 없다|
|단점|각 노드에 장애가 발생할 경우를 대비해 별도의 폴트톨러런스를 구성해야 한다|

##### 2) 공유 디스크
#### 라. 데이터베이스 클러스터의 종류
##### 1) Oracle RAC 데이터베이스 서버
##### 2) IBM DB2 ICE(Integrated Cluster Environment)
##### 3) 마이크로소프트 SQL Server
##### 4) MySQL
<hr>

### 3. NoSQL
#### 가. NoSQL의 개념 및 특징
#### 나. 구글 빅테이블
##### 1) 개념 및 특징
##### 2) 데이터 모델
##### 3) 페일오버
##### 4) AppEngine
#### 다. Hbase
#### 라. 아마존 SimpleDB
#### 마. 마이크로소프트 SSDS
<hr>

## 2절. 분산 컴퓨팅 기술
### 1. MapReduce
#### 가. MapReduce의 개념 및 특징
#### 나. 구글 MapReduce
##### 1) 구글 MapReduce의 개발 배경
##### 2) 프로그래밍 모델: Map과 Reduce라는 2개의 단계로 나눌 수 있음
##### 3) 실행 과정
##### 4) 폴트톨러런스
#### 다. Hadoop MapReduce
##### 1) Haddop MapReduce의 개발 배경
##### 2) 아키텍처
##### 3) Hadoop MapReduce의 실행절차
##### 4) 하둡의 성능
<hr>

### 2. 병렬 쿼리 시스템
#### 가. 병렬 쿼리 시스템의 개요
#### 나. 구글 Sawzall
#### 다. 아파치 Pig
##### 1) 정의 및 특징
##### 2) 개발 배경
##### 3) 사용 예제
#### 라. 아파치 하이브
##### 1) 정의 및 특징
##### 2) 개발배경
##### 3) 하이브 아키텍처
##### 4) 하이브의 언어 모델
<hr>

### 3. SQL on 하둡
#### 가. SQL on 하둡 개요
#### 나. 임팔라의 개념 및 특징
#### 다. 임팔라의 구성요소
#### 라. 임팔라 동작 방식
#### 마. 임팔라의 SQL 구문
#### 바. 임팔라 데이터 모델
<hr>

## 3절. 클라우드 인프라 기술
### 1. 클라우드 컴퓨팅
#### 가. 클라우드 컴퓨팅의 개념 및 특징
#### 나. 서버 가상화의 개념 및 특징
#### 다. 서버 가상화 기술의 효과
<hr>

### 2. CPU 가상화
#### 가. 하이퍼바이저의 개념 및 특징
#### 나. 하이퍼바이저의 기능
#### 다. 하이퍼바이저 관련 기술의 분류
##### 1) 플랫폼별 분류
##### 2) 하이퍼바이저의 위치와 기능에 따른 분류
##### 3) privileged 명령어 처리 방법에 따른 분류
#### 라. 가상화 방식의 분류
##### 1) 완전 가상화
##### 2) 하드웨어 지원 완전 가상화
##### 3) 반가상화
##### 4) Monolithic vs Microkernel
##### 5) 호스트 기반 가상화
##### 6) 컨테이너 기반 가상화
<hr>

### 3. 메모리 가상화
#### 가. 개념 및 특징
#### 나. 가상머신 메모리 할당
#### 다. 가상머신 메모리 할당의 문제 해결을 위한 방법
<hr>

### 4. I/O 가상화
#### 가. 가상 이더넷
#### 나. 공유 이더넷 어댑터
#### 다. 가상 디스크 어댑터
